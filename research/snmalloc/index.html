<!DOCTYPE html>
<html lang="en">
<head>
<title>Exploring snmalloc internals :: RoundofThree</title>
<meta content="text/html; charset=utf-8" http-equiv="content-type"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="Note: this is an updating post.
Introduction snmalloc is a memory allocator by Microsoft Research that uses a &amp;ldquo;message passing&amp;rdquo; scheme. You can find its source code here. It is designed to be performant in highly parallel workloads where memory allocated in one thread is typically deallocated in another thread. A nice catch is that snmalloc is highly customizable, and more to my interest, security mitigations can be customized. It also provides abstraction layers for different architectures (AAL) and platforms (PAL)." name="description"/>
<meta content="[blog pwn ctf morello cheri memory-safety]" name="keywords"/>
<meta content="noodp" name="robots"/>
<link href="/research/snmalloc/" rel="canonical"/>
<link href="/assets/style.css" rel="stylesheet"/>
<link href="/assets/red.css" rel="stylesheet"/>
<link href="/img/apple-touch-icon-192x192.png" rel="apple-touch-icon"/>
<link href="/favicon.png" rel="shortcut icon"/>
<meta content="summary" name="twitter:card"/>
<meta content="" name="twitter:site"/>
<meta content="" name="twitter:creator"/>
<meta content="en" property="og:locale"/>
<meta content="article" property="og:type"/>
<meta content="Exploring snmalloc internals" property="og:title"/>
<meta content="Note: this is an updating post.
Introduction snmalloc is a memory allocator by Microsoft Research that uses a &amp;ldquo;message passing&amp;rdquo; scheme. You can find its source code here. It is designed to be performant in highly parallel workloads where memory allocated in one thread is typically deallocated in another thread. A nice catch is that snmalloc is highly customizable, and more to my interest, security mitigations can be customized. It also provides abstraction layers for different architectures (AAL) and platforms (PAL)." property="og:description"/>
<meta content="/research/snmalloc/" property="og:url"/>
<meta content="RoundofThree" property="og:site_name"/>
<meta content="/favicon.png" property="og:image"/>
<meta content="2048" property="og:image:width"/>
<meta content="1024" property="og:image:height"/>
<meta content="2024-03-14 21:09:58 +0000 UTC" property="article:published_time"/>
</head>
<body class="red">
<div class="container center headings--one-size">
<header class="header">
<div class="header__inner">
<div class="header__logo">
<a href="/">
<div class="logo">
    RoundofThree
  </div>
</a>
</div>
<div class="menu-trigger">menu</div>
</div>
<nav class="menu">
<ul class="menu__inner menu__inner--desktop">
<li><a href="/general">General</a></li>
<li><a href="/labs">Labs</a></li>
<li><a href="/research">Research</a></li>
<li><a href="/">Whoami</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href="/general">General</a></li>
<li><a href="/labs">Labs</a></li>
<li><a href="/research">Research</a></li>
<li><a href="/">Whoami</a></li>
</ul>
</nav>
</header>
<form action="/search/" id="search" method="get">
<label for="search-input" hidden="">Search site</label>
<input id="search-input" name="query" placeholder="Type here to search" type="text"/>
<input type="submit" value="search"/>
</form>
<div class="content">
<div class="post">
<h1 class="post-title">
<a href="/research/snmalloc/">Exploring snmalloc internals</a></h1>
<div class="post-meta">
<span class="post-date">
        2024-03-14 
      </span>
</div>
<span class="post-tags">
    
    #<a href="/tags/malloc/">malloc</a> 
    
  </span>
<div class="table-of-contents">
<h2>
        
          Table of Contents
        
      </h2>
<nav id="TableOfContents">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#custom-configuration">Custom configuration</a></li>
<li><a href="#frontend-vs-backend">Frontend vs backend</a></li>
<li><a href="#frontend-allocation">Frontend allocation</a>
<ul>
<li><a href="#allocators">Allocators</a></li>
<li><a href="#metaentry-vs-slabmetadata">MetaEntry vs SlabMetadata</a></li>
</ul>
</li>
<li><a href="#backend-allocation">Backend allocation</a></li>
<li><a href="#other-concepts">Other concepts</a></li>
<li><a href="#freelist-and-seqset-structs">Freelist and SeqSet structs</a>
<ul>
<li><a href="#freelist-builder">Freelist Builder</a></li>
<li><a href="#freelist-iter">Freelist Iter</a></li>
<li><a href="#seqset-sequential-set">SeqSet (sequential set)</a></li>
<li><a href="#remote-deallocation-queue">Remote deallocation queue</a></li>
</ul>
</li>
<li><a href="#security-checks">Security checks</a></li>
<li><a href="#gef-plugin-for-snmalloc">GEF plugin for snmalloc</a></li>
</ul>
</nav>
</div>
<div class="post-content"><div>
<p><em>Note</em>: this is an updating post.</p>
<h2 id="introduction">Introduction<a arialabel="Anchor" class="hanchor" href="#introduction">⌗</a> </h2>
<p>snmalloc is a memory allocator by Microsoft Research that uses a “message passing” scheme. You can find its source code <a href="https://github.com/microsoft/snmalloc">here</a>. It is designed to be performant in highly parallel workloads where memory allocated in one thread is typically deallocated in another thread.
A nice catch is that snmalloc is highly customizable, and more to my interest, security mitigations can be customized. It also provides abstraction layers for different architectures (AAL) and platforms (PAL).</p>
<p>snmalloc is available as an allocator in CheriBSD, which is a fork of FreeBSD with CHERI support.
Currently, jemalloc is still the default allocator in FreeBSD but we can build with <code>LIBC_MALLOC=snmalloc</code> make options to try snmalloc out.</p>
<p>This article documents my exploration of the internals of snmalloc as available in <a href="https://github.com/microsoft/snmalloc">its official repository</a>.</p>
<h2 id="custom-configuration">Custom configuration<a arialabel="Anchor" class="hanchor" href="#custom-configuration">⌗</a> </h2>
<p>The default behaviour of the snmalloc global memory allocator is defined by the <code>StandardConfig</code> class in <code>backend/globalconfig.h</code> but it can be customized by defining the <code>SNMALLOC_PROVIDE_OWN_CONFIG</code> macro and exporting a customized allocator type as <code>snmalloc::Alloc</code>, as in:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// backend/globalconfig.h
</span><span style="color:#75715e"></span>  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Create allocator type for this configuration.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">using</span> Alloc <span style="color:#f92672">=</span> snmalloc<span style="color:#f92672">::</span>LocalAllocator<span style="color:#f92672">&lt;</span>snmalloc<span style="color:#f92672">::</span>StandardConfig<span style="color:#f92672">&gt;</span>;
</code></pre></div><p>The configuration class defines the implementation of <code>Pagemap</code> and <code>Authmap</code> (only relevant to architectures that support strict provenance, for now just CHERI), the <code>Backend</code> and the <code>LocalState</code>.</p>
<p>We will assume the given standard config in this article.</p>
<h2 id="frontend-vs-backend">Frontend vs backend<a arialabel="Anchor" class="hanchor" href="#frontend-vs-backend">⌗</a> </h2>
<p>There are many mentions of the concepts of frontend and backend in the (quite detailed) documentation in snmalloc’s repository. In simple terms, a frontend allocator gets <em>raw memory chunks</em> from the backend and assigns allocator-specific metadata to them, like sizeclass and slab information. The backend interfaces with the kernel with memory-mapping operations and keeps track of memory chunks to service the frontend.</p>
<p>The backend behavior is defined by the <code>Backend</code> class in the configuration. The frontend behavior is defined by the <code>Alloc</code> class exported by the configuration, which is a <code>LocalAllocator</code>. Each local allocator has an associated core allocator <code>core_alloc</code> of type <code>CoreAlloc</code> and a cache <code>local_cache</code> to hold freelists of small sizeclass.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// mem/localalloc.h
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>SNMALLOC_CONCEPT(IsConfig) Config_<span style="color:#f92672">&gt;</span>
  <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LocalAllocator</span>
  {
    <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// Free list per small size class.  These are used for
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// allocation on the fast path. This part of the code is inspired by
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// mimalloc.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Also contains remote deallocation cache.
</span><span style="color:#75715e"></span>    LocalCache local_cache{<span style="color:#f92672">&amp;</span>Config<span style="color:#f92672">::</span>unused_remote};

    <span style="color:#75715e">// Underlying allocator for most non-fast path operations.
</span><span style="color:#75715e"></span>    CoreAlloc<span style="color:#f92672">*</span> core_alloc{<span style="color:#66d9ef">nullptr</span>};
    
    <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>  }
</code></pre></div><p>The exposed API to the user, eg. <code>malloc</code>, <code>free</code>, <code>realloc</code>, are wrappers around the <code>ThreadAlloc</code> class, which is in turn a wrapper around <code>Alloc</code> (see <code>global/global.h</code> and <code>override/override.h</code>). <code>ThreadAlloc</code> is used to hold a thread-local allocator of configurable type <code>Alloc</code> and the thread-local state. This is similar to tcaches in Linux glibc malloc: each thread has their own local allocator object with their own <code>small_fast_free_lists</code> in <code>local_cache</code>. While local allocators are associated with one core allocator, a core allocator can be associated with many local allocators of different threads, in which case they are sharing the same <em>global</em> state (similar to how different threads share the same <code>fastbins</code>, <code>small_bins</code>, <code>unsorted_bins</code> and <code>large_bins</code> in glibc).</p>
<p>Apart from <code>ThreadAlloc</code>, <code>ScopedAllocator</code> is another wrapper around <code>Alloc</code> that doesn’t depend on thread-local storage, so it can be used as a bootstrapping (slow) allocator, as in <code>test/func/thread_alloc_external/thread_alloc_external.cc</code>.</p>
<h2 id="frontend-allocation">Frontend allocation<a arialabel="Anchor" class="hanchor" href="#frontend-allocation">⌗</a> </h2>
<p>Because the snmalloc code base uses <code>CapPtr&lt;T, B&gt;</code> heavily to annotate pointers to heap memory with <em>bounding</em>, we will use the same terminology to refer to the memory allocations. That is, a certain allocation can be a:</p>
<ul>
<li><code>Alloc</code>: this is owned by the frontend</li>
<li><code>Chunk</code>: the backend manages chunk allocations and returns them to the frontend. This is what I called <em>raw chunks</em>. The frontend assigns metadata to chunks and <em>converts them</em> into allocs</li>
<li><code>Arena</code>: only owned by the backend, which are then further refined into chunks</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// ds_core/ptrwrap.h
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">namespace</span> bounds
    {
      <span style="color:#75715e">/**
</span><span style="color:#75715e">       * Internal access to an entire Arena.  These exist only in the backend.
</span><span style="color:#75715e">       */</span>
      <span style="color:#66d9ef">using</span> Arena <span style="color:#f92672">=</span> bound<span style="color:#f92672">&lt;</span>
        dimension<span style="color:#f92672">::</span>Spatial<span style="color:#f92672">::</span>Arena,
        dimension<span style="color:#f92672">::</span>AddressSpaceControl<span style="color:#f92672">::</span>Full,
        dimension<span style="color:#f92672">::</span>Wildness<span style="color:#f92672">::</span>Tame<span style="color:#f92672">&gt;</span>;

      <span style="color:#75715e">/**
</span><span style="color:#75715e">       * Internal access to a Chunk of memory.  These flow across the boundary
</span><span style="color:#75715e">       * between back- and front-ends, for example.
</span><span style="color:#75715e">       */</span>
      <span style="color:#66d9ef">using</span> Chunk <span style="color:#f92672">=</span> bound<span style="color:#f92672">&lt;</span>
        dimension<span style="color:#f92672">::</span>Spatial<span style="color:#f92672">::</span>Chunk,
        dimension<span style="color:#f92672">::</span>AddressSpaceControl<span style="color:#f92672">::</span>Full,
        dimension<span style="color:#f92672">::</span>Wildness<span style="color:#f92672">::</span>Tame<span style="color:#f92672">&gt;</span>;

      <span style="color:#75715e">/**
</span><span style="color:#75715e">       * User access to an entire Chunk.  Used as an ephemeral state when
</span><span style="color:#75715e">       * returning a large allocation.  See capptr_chunk_is_alloc.
</span><span style="color:#75715e">       */</span>
      <span style="color:#66d9ef">using</span> ChunkUser <span style="color:#f92672">=</span>
        Chunk<span style="color:#f92672">::</span>with_address_space_control<span style="color:#f92672">&lt;</span>dimension<span style="color:#f92672">::</span>AddressSpaceControl<span style="color:#f92672">::</span>User<span style="color:#f92672">&gt;</span>;

      <span style="color:#75715e">/**
</span><span style="color:#75715e">       * Internal access to just one allocation (usually, within a slab).
</span><span style="color:#75715e">       */</span>
      <span style="color:#66d9ef">using</span> AllocFull <span style="color:#f92672">=</span> Chunk<span style="color:#f92672">::</span>with_spatial<span style="color:#f92672">&lt;</span>dimension<span style="color:#f92672">::</span>Spatial<span style="color:#f92672">::</span>Alloc<span style="color:#f92672">&gt;</span>;

      <span style="color:#75715e">/**
</span><span style="color:#75715e">       * User access to just one allocation (usually, within a slab).
</span><span style="color:#75715e">       */</span>
      <span style="color:#66d9ef">using</span> Alloc <span style="color:#f92672">=</span> AllocFull<span style="color:#f92672">::</span>with_address_space_control<span style="color:#f92672">&lt;</span>
        dimension<span style="color:#f92672">::</span>AddressSpaceControl<span style="color:#f92672">::</span>User<span style="color:#f92672">&gt;</span>;

      <span style="color:#75715e">/**
</span><span style="color:#75715e">       * A wild (i.e., putative) CBAllocExport pointer handed back by the
</span><span style="color:#75715e">       * client. See capptr_from_client() and capptr_domesticate().
</span><span style="color:#75715e">       */</span>
      <span style="color:#66d9ef">using</span> AllocWild <span style="color:#f92672">=</span> Alloc<span style="color:#f92672">::</span>with_wildness<span style="color:#f92672">&lt;</span>dimension<span style="color:#f92672">::</span>Wildness<span style="color:#f92672">::</span>Wild<span style="color:#f92672">&gt;</span>;
    } <span style="color:#75715e">// namespace bounds
</span></code></pre></div><p>I know it gets confusing, especially if you have familiarity with other memory allocators that use the same name to refer to different concepts. Shikata ga nai, hopefully I’m clear enough and not confused myself.</p>
<h3 id="allocators">Allocators<a arialabel="Anchor" class="hanchor" href="#allocators">⌗</a> </h3>
<p>As I said, a <code>malloc</code> request first reaches the local allocator. The local allocator is said to handle fast path allocations as it contains freelists in its local cache that store previously freed allocs (think glibc tcache). If there are no allocs of the requested size, it delegates the allocation request to its core allocator and that is slow path allocation. Some key functions exposed by <code>LocalAllocator</code> are:</p>
<ul>
<li><code>alloc</code>
<ul>
<li><code>alloc_not_small</code>: for large requests, request a chunk from the backend and insert into the core allocator <code>laden</code> list of inactive slabs.</li>
<li><code>small_alloc</code>: for requests that are representable in a small sizeclass, first check the local cache. If there are no entries in the small fast freelist, invoke the core allocator <code>small_alloc</code>.</li>
</ul>
</li>
<li><code>dealloc</code>: deallocation is delegated to the core allocator</li>
</ul>
<p>A core allocator is a stateful allocator containing slabs <code>alloc_classes</code> and other fields like <code>laden</code>, <code>entropy</code>, <code>backend_state</code>, <code>attached_cache</code>. Slabs are fixed-size allocations that can be split into smaller. It interfaces with the backend to expose a higher level message object allocation API:</p>
<ul>
<li><code>small_alloc</code>: check for a slab of the requested small sizeclass and get an alloc from the slab. Then update the slab state to inactive if it becomes inactive (moved to <code>laden</code>). <code>BackendSlabMetadata::alloc_free_list</code> fills the small fast freelists in the local cache with the remaining elements in the slab.
<ul>
<li><code>small_alloc_slow</code>: if there is no slab that serves allocs of the requested size, request the backend for a chunk to construct a new slab.</li>
</ul>
</li>
<li><code>dealloc_local_object</code>
<ul>
<li><code>dealloc_local_object_fast</code>: the alloc is inserted into its associated slab freelist.</li>
<li><code>dealloc_local_object_slow</code>: the slow path is triggered when the associated slab has <code>needed_ == 0</code>. If the case of:
<ul>
<li>A large alloc: the chunk is returned to the backend (<code>dealloc_chunk</code>)</li>
<li>A sleeping slab: the addition of a freed object to its freelist hits the threshold to wake up the slab to start servicing requests</li>
<li>An unused slab after this deallocation: this can trigger the deallocation of unused slabs of the same sizeclass if there are enough of them</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-cpp" data-lang="cpp">    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * The number of deallocation required until we hit a slow path. This
</span><span style="color:#75715e">     * counts down in two different ways that are handled the same on the
</span><span style="color:#75715e">     * fast path.  The first is
</span><span style="color:#75715e">     *   - deallocations until the slab has sufficient entries to be considered
</span><span style="color:#75715e">     *   useful to allocate from.  This could be as low as 1, or when we have
</span><span style="color:#75715e">     *   a requirement for entropy then it could be much higher.
</span><span style="color:#75715e">     *   - deallocations until the slab is completely unused.  This is needed
</span><span style="color:#75715e">     *   to be detected, so that the statistics can be kept up to date, and
</span><span style="color:#75715e">     *   potentially return memory to the a global pool of slabs/chunks.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">uint16_t</span> needed_ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</code></pre></div><p>This is a snipped of the core allocator fields.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// class CoreAllocator
</span><span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Define local names for specialised versions of various types that are
</span><span style="color:#75715e">     * specialised for the back-end that we are using.
</span><span style="color:#75715e">     * @{
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">using</span> BackendSlabMetadata <span style="color:#f92672">=</span> <span style="color:#66d9ef">typename</span> Config<span style="color:#f92672">::</span>Backend<span style="color:#f92672">::</span>SlabMetadata;
    <span style="color:#66d9ef">using</span> PagemapEntry <span style="color:#f92672">=</span> <span style="color:#66d9ef">typename</span> Config<span style="color:#f92672">::</span>PagemapEntry;
    <span style="color:#75715e">/// }@
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Per size class list of active slabs for this allocator.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SlabMetadataCache</span>
    {
      SeqSet<span style="color:#f92672">&lt;</span>BackendSlabMetadata<span style="color:#f92672">&gt;</span> available{};

      <span style="color:#66d9ef">uint16_t</span> unused <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
      <span style="color:#66d9ef">uint16_t</span> length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    } alloc_classes[NUM_SMALL_SIZECLASSES]{};

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * The set of all slabs and large allocations
</span><span style="color:#75715e">     * from this allocator that are full or almost full.
</span><span style="color:#75715e">     */</span>
    SeqSet<span style="color:#f92672">&lt;</span>BackendSlabMetadata<span style="color:#f92672">&gt;</span> laden{};
<span style="color:#75715e">// ...
</span></code></pre></div><p>As snmalloc is a message passing allocator, you can expect other message queue operations: <code>init_message_queue</code>, <code>handle_message_queue</code>, <code>post</code>, <code>flush</code>… that I won’t dig in just now.</p>
<p>Additionally, each local allocator is associated with a remote allocator. It represents a message queue of freed objects so that an object can be allocated by one allocator and deallocated by a different allocator in a message passing fashion.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// mem/remoteallocator.h
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">alignas</span>(REMOTE_MIN_ALIGN) RemoteAllocator
  {
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Global key for all remote lists.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * Note that we use a single key for all remote free lists and queues.
</span><span style="color:#75715e">     * This is so that we do not have to recode next pointers when sending
</span><span style="color:#75715e">     * segments, and look up specific keys based on destination.  This is
</span><span style="color:#75715e">     * potentially more performant, but could make it easier to guess the key.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">static</span> FreeListKey key_global{<span style="color:#ae81ff">0xdeadbeef</span>, <span style="color:#ae81ff">0xbeefdead</span>, <span style="color:#ae81ff">0xdeadbeef</span>};

    <span style="color:#66d9ef">using</span> alloc_id_t <span style="color:#f92672">=</span> address_t;

    <span style="color:#75715e">// Store the message queue on a separate cacheline. It is mutable data that
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// is read by other threads.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">alignas</span>(CACHELINE_SIZE) freelist<span style="color:#f92672">::</span>AtomicQueuePtr back{<span style="color:#66d9ef">nullptr</span>};
    <span style="color:#75715e">// Store the two ends on different cache lines as access by different
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// threads.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">alignas</span>(CACHELINE_SIZE) freelist<span style="color:#f92672">::</span>AtomicQueuePtr front{<span style="color:#66d9ef">nullptr</span>};
    <span style="color:#75715e">// Fake first entry
</span><span style="color:#75715e"></span>    freelist<span style="color:#f92672">::</span>Object<span style="color:#f92672">::</span>T<span style="color:#f92672">&lt;</span>capptr<span style="color:#f92672">::</span>bounds<span style="color:#f92672">::</span>AllocWild<span style="color:#f92672">&gt;</span> stub{};
    <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>  }
</code></pre></div><h3 id="metaentry-vs-slabmetadata">MetaEntry vs SlabMetadata<a arialabel="Anchor" class="hanchor" href="#metaentry-vs-slabmetadata">⌗</a> </h3>
<p>Every allocation, be it owned by frontend or backend, has a metaentry stored in the pagemap. However, allocs in the frontend have additional metadata related to the slab and they are stored in <code>SlabMetadata</code> objects. Backend chunks don’t have this same slab metadata because this slab representation is specific to the frontend.</p>
<p>Metaentries are stored in a pagemap. The default <code>FlatPagemap</code> implementation has an array of pointers to metaentries (<code>body</code>).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// ds/pagemap.h
</span><span style="color:#75715e"></span>  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Simple pagemap that for each GRANULARITY_BITS of the address range
</span><span style="color:#75715e">   * stores a T.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>size_t GRANULARITY_BITS, <span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> PAL, <span style="color:#66d9ef">bool</span> has_bounds<span style="color:#f92672">&gt;</span>
  <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FlatPagemap</span>
  {
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> size_t SHIFT <span style="color:#f92672">=</span> GRANULARITY_BITS;
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> size_t GRANULARITY <span style="color:#f92672">=</span> bits<span style="color:#f92672">::</span>one_at_bit(GRANULARITY_BITS);

  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Before init is called will contain a single entry
</span><span style="color:#75715e">     * that is the default value.  This is needed so that
</span><span style="color:#75715e">     * various calls do not have to check for nullptr.
</span><span style="color:#75715e">     *   free(nullptr)
</span><span style="color:#75715e">     * and
</span><span style="color:#75715e">     *   malloc_usable_size(nullptr)
</span><span style="color:#75715e">     * do not require an allocation to have ocurred before
</span><span style="color:#75715e">     * they are called.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> T default_value{};

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * The representation of the page map.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * Initially a single element to ensure nullptr operations
</span><span style="color:#75715e">     * work.
</span><span style="color:#75715e">     */</span>
    T<span style="color:#f92672">*</span> body{<span style="color:#66d9ef">const_cast</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">*&gt;</span>(<span style="color:#f92672">&amp;</span>default_value)};

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * The representation of the pagemap, but nullptr if it has not been
</span><span style="color:#75715e">     * initialised.  Used to combine init checking and lookup.
</span><span style="color:#75715e">     */</span>
    T<span style="color:#f92672">*</span> body_opt{<span style="color:#66d9ef">nullptr</span>};

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * If `has_bounds` is set, then these should contain the
</span><span style="color:#75715e">     * bounds of the heap that is being managed by this pagemap.
</span><span style="color:#75715e">     */</span>
    address_t base{<span style="color:#ae81ff">0</span>};
    size_t size{<span style="color:#ae81ff">0</span>};
<span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>  }
</code></pre></div><p>A metaentry consists of two fields of the size of a pointer of the target architecture: <code>meta</code> and <code>remote_and_sizeclass</code> (abbreviated <code>ras</code>). For an alloc, <code>meta</code> points to its <code>SlabMetadata</code> object, but for chunks in the backend, it can have other meanings. For an alloc, <code>ras</code> encodes a reference to the owning frontend allocator’s message queue <code>RemoteAllocator</code> and the sizeclass. Again, this field has a different meaning for backend owned chunks.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-cpp" data-lang="cpp">  <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MetaEntryBase</span>
  {
  <span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
  <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * In common cases, the pointer to the slab metadata.  See
</span><span style="color:#75715e">     * docs/AddressSpace.md for additional details.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * The bottom bit is used to indicate if this is the first chunk in a PAL
</span><span style="color:#75715e">     * allocation, that cannot be combined with the preceeding chunk.
</span><span style="color:#75715e">     */</span>
    uintptr_t meta{<span style="color:#ae81ff">0</span>};

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * In common cases, a bit-packed pointer to the owning allocator (if any),
</span><span style="color:#75715e">     * and the sizeclass of this chunk.  See `encode` for
</span><span style="color:#75715e">     * details of this case and docs/AddressSpace.md for further details.
</span><span style="color:#75715e">     */</span>
    uintptr_t remote_and_sizeclass{<span style="color:#ae81ff">0</span>};
  <span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>  };
</code></pre></div><p>Every alloc has a slabmetadata object which links it to a slab. A slab consists of a freelist (or two in case the <code>random_preserve</code> mitigation is enabled) of freed allocs.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// [...]
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/**
</span><span style="color:#75715e">     *  Data-structure for building the free list for this slab.
</span><span style="color:#75715e">     */</span>
    SNMALLOC_NO_UNIQUE_ADDRESS freelist<span style="color:#f92672">::</span>Builder<span style="color:#f92672">&lt;</span>mitigations(random_preserve)<span style="color:#f92672">&gt;</span>
      free_queue;

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * The number of deallocation required until we hit a slow path. This
</span><span style="color:#75715e">     * counts down in two different ways that are handled the same on the
</span><span style="color:#75715e">     * fast path.  The first is
</span><span style="color:#75715e">     *   - deallocations until the slab has sufficient entries to be considered
</span><span style="color:#75715e">     *   useful to allocate from.  This could be as low as 1, or when we have
</span><span style="color:#75715e">     *   a requirement for entropy then it could be much higher.
</span><span style="color:#75715e">     *   - deallocations until the slab is completely unused.  This is needed
</span><span style="color:#75715e">     *   to be detected, so that the statistics can be kept up to date, and
</span><span style="color:#75715e">     *   potentially return memory to the a global pool of slabs/chunks.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">uint16_t</span> needed_ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Flag that is used to indicate that the slab is currently not active.
</span><span style="color:#75715e">     * I.e. it is not in a CoreAllocator cache for the appropriate sizeclass.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">bool</span> sleeping_ <span style="color:#f92672">=</span> false;

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Flag to indicate this is actually a large allocation rather than a slab
</span><span style="color:#75715e">     * of small allocations.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">bool</span> large_ <span style="color:#f92672">=</span> false;
<span style="color:#75715e">// [...]
</span></code></pre></div><h2 id="backend-allocation">Backend allocation<a arialabel="Anchor" class="hanchor" href="#backend-allocation">⌗</a> </h2>
<p>The backend manages memory allocations from the platform. This layer deals with <code>Chunk</code>-bounded pointers <code>capptr::Chunk&lt;void&gt;</code>. For every object allocation request, the frontend actually asks for two chunks, one for the slab metadata and one for the user data chunk. Some key functions are:</p>
<ul>
<li><code>alloc_meta_data</code></li>
<li><code>dealloc_meta_data</code></li>
<li><code>alloc_chunk</code></li>
<li><code>dealloc_chunk</code></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-cpp" data-lang="cpp">  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * This class implements the standard backend for handling allocations.
</span><span style="color:#75715e">   * It is parameterised by its Pagemap management and
</span><span style="color:#75715e">   * address space management (LocalState).
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>
    SNMALLOC_CONCEPT(IsPAL) PAL,
    <span style="color:#66d9ef">typename</span> PagemapEntry,
    <span style="color:#66d9ef">typename</span> Pagemap,
    <span style="color:#66d9ef">typename</span> Authmap,
    <span style="color:#66d9ef">typename</span> LocalState<span style="color:#f92672">&gt;</span>
  <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BackendAllocator</span>
</code></pre></div><p>The metadata and the user data chunks are allocated differently. Metadata chunks are serviced by <code>local_state-&gt;get_meta_range()</code> while user data chunks are serviced by <code>local_state-&gt;get_object_range()</code>. What are these ranges? Ranges are similar to passes in compilers: it takes a pointer to a chunk and applies a set of operations to it before returning it. A range exposes the APIs <code>alloc_range</code> and <code>dealloc_range</code>.</p>
<p><code>LocalState</code> contains information about the ranges used by a backend allocator. For example, the default <code>LocalState</code> is defined as:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-cpp" data-lang="cpp">    <span style="color:#66d9ef">using</span> LocalState <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>conditional_t<span style="color:#f92672">&lt;</span>
      mitigations(metadata_protection),
      MetaProtectedRangeLocalState<span style="color:#f92672">&lt;</span>Pal, Pagemap, Base<span style="color:#f92672">&gt;</span>,
      StandardLocalState<span style="color:#f92672">&lt;</span>Pal, Pagemap, Base<span style="color:#f92672">&gt;&gt;</span>;
</code></pre></div><p>And <code>StandardLocalState</code> exposes <code>get_object_range</code> and <code>get_meta_range</code>, so that user chunks are allocated through <code>LargeObjectRange</code> while metadata requests are allocated through <code>ObjectRange</code> (<code>SmallBuddyRange</code> then <code>LargeObjectRange</code>).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">using</span> ObjectRange <span style="color:#f92672">=</span> Pipe<span style="color:#f92672">&lt;</span>LargeObjectRange, SmallBuddyRange<span style="color:#f92672">&gt;</span>;

    ObjectRange object_range;

  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">// Expose a global range for the initial allocation of meta-data.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">using</span> GlobalMetaRange <span style="color:#f92672">=</span> Pipe<span style="color:#f92672">&lt;</span>ObjectRange, GlobalRange<span style="color:#f92672">&gt;</span>;

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Where we turn for allocations of user chunks.
</span><span style="color:#75715e">     *
</span><span style="color:#75715e">     * Reach over the SmallBuddyRange that's at the near end of the ObjectRange
</span><span style="color:#75715e">     * pipe, rather than having that range adapter dynamically branch to its
</span><span style="color:#75715e">     * parent.
</span><span style="color:#75715e">     */</span>
    LargeObjectRange<span style="color:#f92672">*</span> <span style="color:#a6e22e">get_object_range</span>()
    {
      <span style="color:#66d9ef">return</span> object_range.<span style="color:#66d9ef">template</span> ancestor<span style="color:#f92672">&lt;</span>LargeObjectRange<span style="color:#f92672">&gt;</span>();
    }

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * The backend has its own need for small objects without using the
</span><span style="color:#75715e">     * frontend allocators; this range manages those.
</span><span style="color:#75715e">     */</span>
    ObjectRange<span style="color:#f92672">&amp;</span> get_meta_range()
    {
      <span style="color:#75715e">// Use the object range to service meta-data requests.
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> object_range;
    }
<span style="color:#75715e">// ...
</span></code></pre></div><h2 id="other-concepts">Other concepts<a arialabel="Anchor" class="hanchor" href="#other-concepts">⌗</a> </h2>
<p>Other concepts (I will dig into in the future):</p>
<ul>
<li>Domestication: see <code>capptr_domesticate</code>. This concerns inter-thread memory allocation requests.</li>
<li>Authmap: this is used to enforce strict provenance in AALs that support strict provenance (currently only AALs with AAL_CHERI mixin).</li>
</ul>
<h2 id="freelist-and-seqset-structs">Freelist and SeqSet structs<a arialabel="Anchor" class="hanchor" href="#freelist-and-seqset-structs">⌗</a> </h2>
<p>Snmalloc uses four iterable structures to link objects.</p>
<h3 id="freelist-builder">Freelist Builder<a arialabel="Anchor" class="hanchor" href="#freelist-builder">⌗</a> </h3>
<p>A builder can contain two freelist queues depending on whether <code>random_preserve</code> mitigation is enabled.
As per the comments, it is used to build a freelist in object space.</p>
<ul>
<li>
<p>What is the structure of a freelist builder?</p>
<ul>
<li><code>head</code>: pointer to the first element, aka FreelistPtr</li>
<li><code>end</code>: pointer to pointer to the last element, aka pointer to FreelistPtr</li>
</ul>
</li>
<li>
<p>What uses a freelist builder?</p>
<ul>
<li><code>FrontendSlabMetadata-&gt;free_queue</code> keeps track of active <code>Alloc</code>s under the slab</li>
<li><code>RemoteDeallocCache-&gt;lists</code> is an array of <code>Builder</code></li>
</ul>
</li>
<li>
<p>How is it iterated?</p>
<ul>
<li>Empty case: <code>end == &amp;head</code></li>
<li>First element: <code>curr = head</code></li>
<li>Next element: <code>curr.next_object</code></li>
<li>Last element: <code>curr == end</code> (<code>curr</code> included)</li>
</ul>
</li>
</ul>
<h3 id="freelist-iter">Freelist Iter<a arialabel="Anchor" class="hanchor" href="#freelist-iter">⌗</a> </h3>
<p>Used to iterate a freelist in object space.</p>
<ul>
<li>
<p>What is the structure of a freelist iter?</p>
<ul>
<li><code>curr</code>: freelist pointer, aka pointer to the first element</li>
</ul>
</li>
<li>
<p>What uses a freelist iter?</p>
<ul>
<li><code>LocalCache-&gt;small_fast_free_lists</code> is a primitive array of freelist iters</li>
</ul>
</li>
<li>
<p>How is it iterated?</p>
<ul>
<li>Empty case: <code>curr == nullptr</code></li>
<li>First element: <code>curr</code></li>
<li>Next element: <code>curr.next_object</code></li>
<li>Last element: right before the empty case (null terminator)</li>
</ul>
</li>
</ul>
<h3 id="seqset-sequential-set">SeqSet (sequential set)<a arialabel="Anchor" class="hanchor" href="#seqset-sequential-set">⌗</a> </h3>
<p>Doubly-linked cyclic list linked using T::node field.
Used to group slab metadata in metadata space (not used in object space).</p>
<ul>
<li>
<p>What is the structure of a seqset?</p>
<ul>
<li><code>head</code>: a SeqSetNode (containing pointers next and prev)</li>
</ul>
</li>
<li>
<p>What uses a seqset?</p>
<ul>
<li>Core allocator <code>laden</code> groups <code>FrontendSlabMetadata</code></li>
<li>Core allocator <code>alloc_classes</code> contained <code>available</code> which groups <code>FrontendSlabMetadata</code></li>
</ul>
</li>
<li>
<p>How is it iterated?</p>
<ul>
<li>Empty case: <code>head.next == &amp;head</code></li>
<li>First case: <code>curr = head.next</code></li>
<li>Next case: <code>curr.next</code> (or <code>curr.prev</code>)</li>
<li>Last case: right before the empty case</li>
</ul>
</li>
</ul>
<h3 id="remote-deallocation-queue">Remote deallocation queue<a arialabel="Anchor" class="hanchor" href="#remote-deallocation-queue">⌗</a> </h3>
<p>The remote deallocation queue uses a different iterable struct.</p>
<ul>
<li>
<p>What is the structure of a remote deallocation queue?</p>
<ul>
<li><code>back</code>: freelist pointer</li>
<li><code>front</code>: freelist pointer</li>
<li><code>stub</code>: fake first entry</li>
</ul>
</li>
<li>
<p>How is it iterated?</p>
<ul>
<li>Empty case: <code>front == &amp;stub</code> or <code>back == nullptr</code></li>
<li>First element: <code>curr = front</code></li>
<li>Next element: <code>curr.next_object</code></li>
<li>Last element: right before <code>curr == nullptr</code> or <code>curr == back</code> (curr not included)</li>
</ul>
</li>
</ul>
<h2 id="security-checks">Security checks<a arialabel="Anchor" class="hanchor" href="#security-checks">⌗</a> </h2>
<p>The security checks are nicely grouped in the <code>ds_core/mitigations.h</code> header file.
One future research question would be, how do these security mitigations affect the exploitability of memory safety bugs? One could test the added exploit constraints under different combinations of enabled security mitigations.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-cpp" data-lang="cpp">  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Randomize the location of the pagemap within a larger address space
</span><span style="color:#75715e">   * allocation.  The other pages in that allocation may fault if accessed, on
</span><span style="color:#75715e">   * platforms that can efficiently express such configurations.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * This guards against adversarial attempts to access the pagemap.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * This is unnecessary on StrictProvenance architectures.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">constexpr</span> mitigation<span style="color:#f92672">::</span>type random_pagemap{<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">0</span>};
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Ensure that every slab (especially slabs used for larger "small" size
</span><span style="color:#75715e">   * classes) has a larger minimum number of objects and that a larger
</span><span style="color:#75715e">   * percentage of objects in a slab must be free to awaken the slab.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * This should frustrate use-after-reallocation attacks by delaying reuse.
</span><span style="color:#75715e">   * When combined with random_preserve, below, it additionally ensures that at
</span><span style="color:#75715e">   * least some shuffling of free objects is possible, and, hence, that there
</span><span style="color:#75715e">   * is at least some unpredictability of reuse.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * TODO: should this be split? mjp: Would require changing some thresholds.
</span><span style="color:#75715e">   * The min waking count needs to be ensure we have enough objects on a slab,
</span><span style="color:#75715e">   * hence is related to the min count on a slab.  Currently we without this, we
</span><span style="color:#75715e">   * have min count of slab of 16, and a min waking count with this enabled
</span><span style="color:#75715e">   * of 32. So we would leak memory.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">constexpr</span> mitigation<span style="color:#f92672">::</span>type random_larger_thresholds{<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span>};
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * Obfuscate forward-edge pointers in intra-slab free lists.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * This helps prevent a UAF write from re-pointing the free list arbitrarily,
</span><span style="color:#75715e">   * as the de-obfuscation of a corrupted pointer will generate a wild address.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * This is not available on StrictProvenance architectures.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">constexpr</span> mitigation<span style="color:#f92672">::</span>type freelist_forward_edge{<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">2</span>};
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Store obfuscated backward-edge addresses in intra-slab free lists.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * Ordinarily, these lists are singly-linked.  Storing backward-edges allows
</span><span style="color:#75715e">   * the allocator to verify the well-formedness of the links and, importantly,
</span><span style="color:#75715e">   * the acyclicity of the list itself.  These backward-edges are also
</span><span style="color:#75715e">   * obfuscated in an attempt to frustrate an attacker armed with UAF
</span><span style="color:#75715e">   * attempting to construct a new well-formed list.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * Because the backward-edges are not traversed, this is available on
</span><span style="color:#75715e">   * StrictProvenance architectures, unlike freelist_forward_edge.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * This is required to detect double frees as it will break the doubly linked
</span><span style="color:#75715e">   * nature of the free list.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">constexpr</span> mitigation<span style="color:#f92672">::</span>type freelist_backward_edge{<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">3</span>};
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * When de-purposing a slab (releasing its address space for reuse at a
</span><span style="color:#75715e">   * different size class or allocation), walk the free list and validate the
</span><span style="color:#75715e">   * domestication of all nodes along it.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * If freelist_forward_edge is also enabled, this will probe the
</span><span style="color:#75715e">   * domestication status of the de-obfuscated pointers before traversal.
</span><span style="color:#75715e">   * Each of domestication and traversal may probabilistically catch UAF
</span><span style="color:#75715e">   * corruption of the free list.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * If freelist_backward_edge is also enabled, this will verify the integrity
</span><span style="color:#75715e">   * of the free list links.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * This gives the allocator "one last chance" to catch UAF corruption of a
</span><span style="color:#75715e">   * slab's free list before the slab is de-purposed.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * This is required to comprehensively detect double free.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">constexpr</span> mitigation<span style="color:#f92672">::</span>type freelist_teardown_validate{<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">4</span>};
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * When initializing a slab, shuffle its free list.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * This guards against attackers relying on object-adjacency or address-reuse
</span><span style="color:#75715e">   * properties of the allocation stream.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">constexpr</span> mitigation<span style="color:#f92672">::</span>type random_initial{<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">5</span>};
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * When a slab is operating, randomly assign freed objects to one of two
</span><span style="color:#75715e">   * intra-slab free lists.  When selecting a slab's free list for allocations,
</span><span style="color:#75715e">   * select the longer of the two.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * This guards against attackers relying on object-adjacency or address-reuse
</span><span style="color:#75715e">   * properties of the allocation stream.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">constexpr</span> mitigation<span style="color:#f92672">::</span>type random_preserve{<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">6</span>};
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Randomly introduce another slab for a given size-class, rather than use
</span><span style="color:#75715e">   * the last available to an allocator.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * This guards against attackers relying on address-reuse, especially in the
</span><span style="color:#75715e">   * pathological case of a size-class having only one slab with free entries.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">constexpr</span> mitigation<span style="color:#f92672">::</span>type random_extra_slab{<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">7</span>};
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Use a LIFO queue, rather than a stack, of slabs with free elements.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * This generally increases the time between address reuse.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">constexpr</span> mitigation<span style="color:#f92672">::</span>type reuse_LIFO{<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>};
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * This performs a variety of inexpensive "sanity" tests throughout the
</span><span style="color:#75715e">   * allocator:
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * - Requests to free objects must
</span><span style="color:#75715e">   *   - not be interior pointers
</span><span style="color:#75715e">   *   - be of allocated address space
</span><span style="color:#75715e">   * - Requests to free objects which also specify the size must specify a size
</span><span style="color:#75715e">   *   that agrees with the current allocation.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * This guards gainst various forms of client misbehavior.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * TODO: Should this be split? mjp: It could, but let's not do this until
</span><span style="color:#75715e">   * we have performance numbers to see what this costs.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">constexpr</span> mitigation<span style="color:#f92672">::</span>type sanity_checks{<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">9</span>};
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * On CHERI, perform a series of well-formedness tests on capabilities given
</span><span style="color:#75715e">   * when requesting to free an object.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">constexpr</span> mitigation<span style="color:#f92672">::</span>type cheri_checks{<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">10</span>};
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Erase intra-slab free list metadata before completing an allocation.
</span><span style="color:#75715e">   *
</span><span style="color:#75715e">   * This mitigates information disclosure.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">constexpr</span> mitigation<span style="color:#f92672">::</span>type clear_meta{<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">11</span>};
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * Protect meta data blocks by allocating separate from chunks for
</span><span style="color:#75715e">   * user allocations. This involves leaving gaps in address space.
</span><span style="color:#75715e">   * This is less efficient, so should only be applied for the checked
</span><span style="color:#75715e">   * build.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">constexpr</span> mitigation<span style="color:#f92672">::</span>type metadata_protection{<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">12</span>};
  <span style="color:#75715e">/**
</span><span style="color:#75715e">   * If this mitigation is enabled, then Pal implementations should provide
</span><span style="color:#75715e">   * exceptions/segfaults if accesses do not obey the
</span><span style="color:#75715e">   *  - using
</span><span style="color:#75715e">   *  - using_readonly
</span><span style="color:#75715e">   *  - not_using
</span><span style="color:#75715e">   * model.
</span><span style="color:#75715e">   */</span>
  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> mitigation<span style="color:#f92672">::</span>type pal_enforce_access{<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">13</span>};
</code></pre></div><h2 id="gef-plugin-for-snmalloc">GEF plugin for snmalloc<a arialabel="Anchor" class="hanchor" href="#gef-plugin-for-snmalloc">⌗</a> </h2>
<p>I have developed a GEF plugin that adds a heap manager that understands snmalloc heap. It is limited to the default configuration and the default set of security mitigations.
You can read more in <a href="../labs/gef-cheri.md">this other blog post</a> or <a href="https://github.com/CTSRD-CHERI/gef-plugins">check it out</a>.</p>
<p><em>Note</em>: the plugin requires GEF with CHERI support because it assumes a separation of <em>address space size</em> (<code>adrsize</code>) and <em>pointer size</em> (<code>ptrsize</code>). The original GEF assumes <code>adrsize == ptrsize</code> but this is not true for CHERI-enabled architectures.</p>
</div></div>
</div>
</div>
<footer class="footer">
<div class="footer__inner">
<div class="copyright copyright--user">
<span>© 2024 RoundofThree</span>
</div>
</div>
</footer>
<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>
</div>
</body>
</html>
